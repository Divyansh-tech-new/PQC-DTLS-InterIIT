#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <wolfssl/wolfcrypt/types.h>

// LiteX Hardware
#include <irq.h>
#include <libbase/uart.h>
#include <libbase/console.h>
#include <generated/csr.h>

// WolfSSL
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/ssl.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/wolfcrypt/random.h>
#include <wolfssl/wolfcrypt/dilithium.h>
#include <wolfssl/wolfcrypt/mlkem.h>
#include <wolfssl/wolfcrypt/wc_mlkem.h> // Internal header for MlKemKey struct definition


/* Bypass certificate date validation in simulation (no RTC) */
#ifndef WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY
#define WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY  0x00000002
#endif

// PQC Certificates (embedded as byte arrays)
#include "pqc_certs.h"

/* =========================================================================
   CONFIG: Change this to switch between client/server mode
   ========================================================================= */
#define MODE_SERVER 0  // Set to 1 for server, 0 for client
#define DEMO_MODE   0  // Set to 0 for real DTLS handshake

/* =========================================================================
   QUIET MODE: Disable printf during DTLS handshake
   When enabled, only DTLS binary packets go through UART (not debug text)
   ========================================================================= */
static volatile int quiet_mode = 0;

#define DPRINT(...) do { if (!quiet_mode) printf(__VA_ARGS__); } while(0)
#define ENABLE_QUIET()  do { quiet_mode = 1; } while(0)
#define DISABLE_QUIET() do { quiet_mode = 0; } while(0)

/* =========================================================================
   TIMING & ENTROPY
   ========================================================================= */
static int timer_initialized = 0;

/* Mock RTC time: Jan 1 2026 (Epoch: 1767225600) */
#define RTC_OFFSET_SEC  1766275200

void timer_init_setup(void) {
    timer0_en_write(0);
    timer0_load_write(0xFFFFFFFF);
    timer0_reload_write(0xFFFFFFFF);
    timer0_en_write(1);
    timer_initialized = 1;
}

int gettimeofday(struct timeval* tv, void* tz) {
    if (!timer_initialized) timer_init_setup();
    
    timer0_update_value_write(1);
    uint32_t current_ticks = timer0_value_read();
    uint32_t elapsed_us = 0xFFFFFFFF - current_ticks;
    
    if (tv) {
        tv->tv_sec = RTC_OFFSET_SEC + (elapsed_us / 1000000);
        tv->tv_usec = elapsed_us % 1000000;
    }
    return 0;
}

// Low-resolution timer required by wolfSSL when using USER_TICKS.
// Returns a monotonically increasing count in *seconds*.
// Mocks a valid date (Jan 2025) to satisfy certificate validity.
// Custom time function for wolfSSL (replaces XTIME)
// Returns seconds since epoch (mocked to 2025)
// Must populate 'timer' pointer if not NULL
unsigned long custom_time(unsigned long* timer)
{
    if (!timer_initialized)
        timer_init_setup();

    // Update timer value from LiteX CSR
    timer0_update_value_write(1);
    uint32_t current_ticks = timer0_value_read();

    // Timer counts down from 0xFFFFFFFF; convert to elapsed microseconds
    uint32_t elapsed_us = 0xFFFFFFFFu - current_ticks;

    // Convert to seconds and add mock RTC offset
    unsigned long now = (unsigned long)(RTC_OFFSET_SEC + (elapsed_us / 1000000u));

    if (timer != NULL) {
        *timer = now;
    }
    
    return now;
}

// Keep LowResTimer for backward compatibility if needed (it takes no args)
word32 LowResTimer(void) {
    return (word32)custom_time(0);
}


int CustomRngGenerateBlock(byte *output, word32 sz) {
    uart_write('R'); // Trace RNG calls
    timer0_update_value_write(1);
    uint32_t seed = timer0_value_read();
    
    for (word32 i = 0; i < sz; i++) {
        seed = seed * 1103515245 + 12345;
        output[i] = (byte)((seed >> 16) ^ (i & 0xFF));
    }

    srand(seed);
    for (int i = 0; i < sz; i++) {
        output[i] = (byte)rand();
    }
    
    return 0;
}

/* =========================================================================
   UART I/O CALLBACKS
   ========================================================================= */
int my_IORecv(WOLFSSL *ssl, char *buff, int sz, void *ctx) {
    int ret = 0;
    while (ret < sz) {
        int ch = uart_read_nonblock();
        if (ch == -1) {
            if (ret > 0) break; // Return what we have
             return WOLFSSL_CBIO_ERR_WANT_READ;
        }
        buff[ret++] = (char)ch;
    }
    return ret;
}

int my_IOSend(WOLFSSL *ssl, char *buff, int sz, void *ctx) {
    for (int i = 0; i < sz; i++) {
        uart_write(buff[i]);
    }
    return sz;
}

/* =========================================================================
   CERTIFICATE CALLBACKS FOR MUTUAL AUTHENTICATION
   ========================================================================= */

/* Verify peer certificate callback */
int my_verify_callback(int preverify, WOLFSSL_X509_STORE_CTX* store) {
    (void)preverify;
    (void)store;
    
    /* Certificate verification (silent for speed) */
    return 1;  /* 1 = accept, 0 = reject */
}

/* =========================================================================
   PQC CONFIGURATION WITH DILITHIUM CERTIFICATES
   ========================================================================= */
#if 1
int configure_pqc_context(WOLFSSL_CTX* ctx, int is_server) {
   // ...
}
void run_dtls_client(void) {
    // ...
}
void run_dtls_server(void) {
   // ...
}
#endif

/* =========================================================================
   MAIN
   ========================================================================= */
int main(void) {
    uart_init();
#ifdef CONFIG_CPU_HAS_INTERRUPT
    // uart_write('X'); // Avoid writing before confirmed init
    irq_setmask(0);
    irq_setie(1);
#endif
    
    // uart_init(); // Moved up
    timer_init_setup();
    
    printf("\n=== DTLS 1.3 PQC Demo ===\n");
    printf("ML-KEM-512 + Dilithium L2\n");
    
    if (wolfSSL_Init() != WOLFSSL_SUCCESS) {
        printf("ERROR: Init failed\n");
        return -1;
    }

    // wolfSSL_Debugging_ON();  
    
#if MODE_SERVER
    printf("[DEBUG] Compiled as SERVER\n");
    run_dtls_server();
#else
    printf("[DEBUG] Compiled as CLIENT\n");
    run_dtls_client();
#endif
    
    wolfSSL_Cleanup();
    
    printf("\n[Done]\n");
    
    return 0;
}
